<?php

/**
 * Custom SmartParticipation moderation functionality on both front end and moderator
 * interface.
 */
 

/**
 * Page callback to generate the moderator interface.
 *
 */
function smartparticipation_core_moderator_page() {
  $items = array();

  // Default results on moderator page
  smartparticipation_core_get_comments_data($items, 'newest', '', 'all', 'all_comments', 0, 5, '');

  $items['interest_survey'] = theme('dialog', array(
      'dlgId' => 'dlgSurvey',
      //'title' => t('Interest Survey'),
      'content' => '',
  ));

  // Return a render array
  return array(
    '#items' => $items,
    '#theme' => 'moderator',
  );  
}

function smartparticipation_core_moderator_access() {
  
  // NB NOT user_access('administer comments') because user_access()
  // gives all privileges to user #1.
  return(smartparticipation_core_user_is_moderator());
}


/**
 * Generate moderator-specific comment links. 
 * 
 * TODO The moderator interface should use this as well.
 * 
 * NB Recommend is added as a flag, rather than here as a link.
 */
function smartparticipation_core_moderator_comment_links(&$variables, $subtopic_allows_commenting) {

  // Subtopic closed for commenting
  if (!$subtopic_allows_commenting) {
    
    unset($variables['content']['links']['comment']['#links']);
    /*$variables['content']['links']['comment']['#links']['endorsement-counter'] =
      smartparticipation_core_comment_endorsement_counter_link($variables['comment']);*/
    
  // Subtopic open for commenting
  } else {
    
    // Remove delete function
    unset($variables['content']['links']['comment']['#links']['comment-delete']);
    
    // Remove approve button generated by Druapl when the comment is quarantined.
    // TODO The larger problem is that the comment should fade out on the front
    // end after quarantining, but doesn't. The button doesn't appear in the
    // moderator interface.
    unset($variables['content']['links']['comment']['#links']['comment-approve']);
          
    // Moderator comment: only show redact link, so comment can be modified.
    if (smartparticipation_core_is_moderator_comment($variables['comment'])) {
      unset($variables['content']['links']['comment']['#links']['comment-reply']);
      smartparticipation_core_comment_redact_link($variables);
      
    } else {
     
      /*$endorsement_counter = smartparticipation_core_comment_endorsement_counter_link($variables['comment'], true);
      $variables['content']['links']['comment']['#links']['endorsement-counter'] =
          $endorsement_counter;*/
      $user_service = new \SmartParticipation\UserService;
      $user = $user_service->find();
      if ($user_service::isAdmin($user)) {
        smartparticipation_core_comment_endorse_link($variables);
      }
      // TODO Make sure this same order is followed in the moderator interface.
      smartparticipation_core_comment_status_and_action_links($variables);
      smartparticipation_core_comment_add_note_link($variables);
      smartparticipation_core_comment_redact_link($variables);
      smartparticipation_core_comment_reply_link($variables, true);
      smartparticipation_core_comment_quarantine_link($variables);
      smartparticipation_core_comment_no_reply_link($variables);
      smartparticipation_core_comment_recommend_link($variables);
    }

  }
  
  unset($variables['content']['links']['flag']);

  // Theme for rendering the links
  $variables['content']['links']['#theme'] = 'comment_links_moderator';

}

function smartparticipation_core_comment_status_and_action_links(&$variables) {
 
  // Status indicator
  // TODO Turn this into a standard Drupal render array, rather than an array
  // with custom keys that the template hard-codes. Then the template should 
  // call render() on the link.
  $status = array();
  $status_value = $variables['field_sp_comment_mod_status'][0]['value'];
  $status['class'] = str_replace('_', '-', $status_value);
  $status['value'] = t(str_replace('_', ' ', $status_value));
  $variables['content']['links']['comment']['comment-status'] = $status;
  
  // Action indicator
  // TODO Turn this into a standard Drupal render array, rather than an array
  // with custom keys that the template hard-codes. Then the template should 
  // call render() on the link.
  if (isset($variables['field_sp_comment_mod_action'])) {
    $action_value = $variables['field_sp_comment_mod_action'][0]['value'];
    if ($action_value) {
      $action = array();
      $action['class'] = str_replace('_', '-', $action_value);
      $action['value'] = t(str_replace('_', ' ', $action_value));
      $variables['content']['links']['comment']['comment-action'] = $action;  
    }
  }
  
  // In progress button
  if ($status_value != 'in_progress') {
    smartparticipation_core_comment_in_progress_link($variables);
  }
    
}

function smartparticipation_core_comment_in_progress_link(&$variables) {

  $cid = $variables['comment']->cid;
      
  $comment_in_progress = array();
  $comment_in_progress['title'] = t('Mark in progress');
  $path = 'comment/' . $cid . '/in_progress';
  $comment_in_progress['href'] = $path;
  $comment_in_progress['query'] = array('token' => drupal_get_token($path));
  $comment_in_progress['html'] = TRUE;    
  $variables['content']['links']['comment']['#links']['comment-in-progress'] = $comment_in_progress;
      
}

function smartparticipation_core_comment_add_note_link(&$variables) {

  $cid = $variables['comment']->cid;
  
  $comment_note = array();
  $comment_note['title'] = t('Add note');
  /*TODO change to ajax version */
  // $comment_note['href'] = 'node/add/smartparticipation_core-comment-note?field_sp_comment_note_comment=' . $cid;
  $path = 'comment/' . $cid . '/add_note';
  $comment_note['href'] = $path;
  $comment_note['query'] = array('token' => drupal_get_token($path));
  $comment_note['html'] = TRUE;
  $variables['content']['links']['comment']['#links']['comment-note'] = $comment_note;

}

function smartparticipation_core_comment_redact_link(&$variables) {

  $title = (smartparticipation_core_is_moderator_comment($variables['comment']) ? 'Edit' : 'Redact');
  $variables['content']['links']['comment']['#links']['comment-edit']['title'] = $title;
  $variables['content']['links']['comment']['#links']['comment-redact'] =
    $variables['content']['links']['comment']['#links']['comment-edit'];
  unset($variables['content']['links']['comment']['#links']['comment-edit']);

  /*$cid = $variables['comment']->cid;
      
  $comment_redact = array();
  
  $title = (smartparticipation_core_is_moderator_comment($variables['comment']) ? 'Edit' : 'Redact');
  $comment_redact['title'] = t($title);
  $path = 'comment/' . $cid . '/redact';
  $comment_redact['href'] = $path;
  $comment_redact['query'] = array('token' => drupal_get_token($path));
  $comment_redact['html'] = TRUE;    
  $variables['content']['links']['comment']['#links']['comment-redact'] = $comment_redact;*/

}

function smartparticipation_core_comment_quarantine_link(&$variables) {

  $comment = $variables['comment'];
  $cid = $comment->cid;
  
  $comment_quarantine = array();

  if (!smartparticipation_core_comment_quarantined($comment)) {
    $comment_quarantine['title'] = t('Quarantine');
    $path = 'comment/' . $cid . '/quarantine';
  } else{
    $comment_quarantine['title'] = t('Unquarantine');
    $path = 'comment/' . $cid . '/unquarantine';
  }

  $comment_quarantine['href'] = $path;
  $comment_quarantine['html'] = TRUE;
  $comment_quarantine['query'] = array('token' => drupal_get_token($path));
  $variables['content']['links']['comment']['#links']['comment-quarantine'] = $comment_quarantine;

}

function smartparticipation_core_comment_no_reply_link(&$variables) {

  $cid = $variables['comment']->cid;
  
  $comment_no_reply = array();  
  $comment_no_reply['title'] = t('No reply');
  $path = 'comment/' . $cid . '/no_reply';
  $comment_no_reply['href'] = $path;
  $comment_no_reply['html'] = TRUE;
  $comment_no_reply['query'] = array('token' => drupal_get_token($path));
  $variables['content']['links']['comment']['#links']['comment-no-reply'] = $comment_no_reply;
  
}   

function smartparticipation_core_comment_recommend_link(&$variables) {

  $cid = $variables['comment']->cid;
  
  $flag = flag_get_flag('comment_recommendation');
  
  $link_title = $flag->flag_short;
  // $path = 'flag/flag/comment_recommendation/' . $cid;
  
  if ($flag->is_flagged($cid)) {
    $link_title = $flag->unflag_short;
    // $path = 'flag/unflag/comment_recommendation/' . $cid;
  }

  // Adding and removing recommendation go to same url.
  $path = 'comment/' . $cid . '/recommend'; 
  
  $comment_recommend = array();
  $comment_recommend['title'] = $link_title;
  $comment_recommend['href'] = $path;
  $comment_recommend['html'] = TRUE;
  $comment_recommend['query'] = array('destination' => 'node/'.arg(1), 'token' => drupal_get_token($path));
  $variables['content']['links']['comment']['#links']['comment-recommend'] = $comment_recommend;  

} 

  
/**
 * Menu callback; quarantine the specified comment.
 *
 * @param $cid
 *   A comment identifier.
 */
function smartparticipation_core_comment_quarantine($cid) {
  
  if (!isset($_GET['token']) || (!drupal_valid_token($_GET['token'], "comment/$cid/quarantine") && !drupal_valid_token($_GET['token'], "moderator/comment/$cid/action"))) {
    return MENU_ACCESS_DENIED;
  }
  
  if ($comment = comment_load($cid)) {
    
    $comment->field_sp_comment_mod_status[LANGUAGE_NONE][0]['value'] = 'done';
    $comment->field_sp_comment_mod_action[LANGUAGE_NONE][0]['value'] = 'quarantine';

    comment_save($comment);

    if (drupal_valid_token($_GET['token'], "comment/$cid/quarantine")) {
      drupal_json_output(smartparticipation_core_comment_front_end_render_response($cid));
    } else if (drupal_valid_token($_GET['token'], "moderator/comment/$cid/action")) {
      return 'activate';
    } else{
      return MENU_NOT_FOUND;
    }
  } else{
    return MENU_NOT_FOUND;
  }
}

/**
 * Menu callback; unquarantine specified comment.
 *
 * @param $cid
 *   A comment identifier.
 */
function smartparticipation_core_comment_unquarantine($cid) {
  
  if (!isset($_GET['token']) || (!drupal_valid_token($_GET['token'], "comment/$cid/unquarantine") && !drupal_valid_token($_GET['token'], "moderator/comment/$cid/action"))) {
    return MENU_ACCESS_DENIED;
  }
  
  if ($comment = comment_load($cid)) {

    $comment->field_sp_comment_mod_status[LANGUAGE_NONE][0]['value'] = 'in_progress';
    
    // Remove mod action as this goes back to in_progress.
    // NB This will correctly remove the record from the table.
    $comment->field_sp_comment_mod_action = NULL;

    comment_save($comment);


    if (drupal_valid_token($_GET['token'], "comment/$cid/unquarantine")) {
      drupal_json_output(smartparticipation_core_comment_front_end_render_response($cid));
    } else if (drupal_valid_token($_GET['token'], "moderator/comment/$cid/action")) {
      return "deactivate";
    } else{
      return MENU_NOT_FOUND;
    }
  }
}


/**
 * Menu callback; moves the specified comment to "done" state.
 *
 * @param $cid
 *   A comment identifier.
 */
function smartparticipation_core_comment_no_reply($cid) {
  
  /*if (!isset($_GET['token']) || (!drupal_valid_token($_GET['token'], "comment/$cid/no_reply") && !drupal_valid_token($_GET['token'], "moderator/comment/$cid/action"))) {
    return MENU_ACCESS_DENIED;
  }*/
  
  if ($comment = comment_load($cid)) {
    
    // If this is already in the no_reply state, send a 'no effect' state back
    if (smartparticipation_core_field_get_item_value('comment', $comment, 'field_sp_comment_mod_action', 'value') == 'no_reply' &&
        drupal_valid_token($_GET['token'], "moderator/comment/$cid/action")) {
      return 'no effect';
    
    } else {

      $comment->field_sp_comment_mod_status[LANGUAGE_NONE][0]['value'] = 'done';
      $comment->field_sp_comment_mod_action[LANGUAGE_NONE][0]['value'] = 'no_reply';

      comment_save($comment);
    }

    if (drupal_valid_token($_GET['token'], "comment/$cid/no_reply")) {
      drupal_json_output(smartparticipation_core_comment_front_end_render_response($cid));     
    } else if (drupal_valid_token($_GET['token'], "moderator/comment/$cid/action")) {
      return "activate";
    } else{
      return MENU_NOT_FOUND;
    }
  }
}

/**
 * Menu callback; moves the specified comment to "in progress" state.
 *
 * @param $cid - A comment identifier.
 */
function smartparticipation_core_comment_in_progress($cid) {
  
  if (!isset($_GET['token']) || 
      (!drupal_valid_token($_GET['token'], "comment/$cid/in_progress") && 
       !drupal_valid_token($_GET['token'], "moderator/comment/$cid/action"))) {
    return MENU_ACCESS_DENIED;
  }
  
  if ($comment = comment_load($cid)) {
    
    if (smartparticipation_core_field_get_item_value('comment', $comment, 'field_sp_comment_mod_status', 'value') != 'in_progress') {

      $comment->field_sp_comment_mod_status[LANGUAGE_NONE][0]['value'] = 'in_progress';
      
      // NB This will correctly remove the record from the table.
      $comment->field_sp_comment_mod_action = NULL;
      
    } else if (drupal_valid_token($_GET['token'], "moderator/comment/$cid/action")) {
      return 'no effect';
    }

    comment_save($comment);

    if (drupal_valid_token($_GET['token'], "comment/$cid/in_progress")) {
      drupal_json_output(smartparticipation_core_comment_front_end_render_response($cid));  
    } else if (drupal_valid_token($_GET['token'], "moderator/comment/$cid/action")) {
      return 'activate';
    } else{
      return MENU_NOT_FOUND;
    }
  }
}

/**
 * Redact a user comment or edit a moderator comment.
 *
 * @param $cid - the comment identifier.
 * @param $content - the new body content for the comment.
 */
function smartparticipation_core_comment_redact($cid, $content = null) {
  
  if ($comment = comment_load($cid)) {
    // From front-end attempt to gather content information from GET
    if ($content == null) {
      if (!empty($_REQUEST['content'])) {
        $content = $_REQUEST['content'];
      } else if (!empty($_GET['input'])) {
        $content = $_GET['input'];
      } else {
        return MENU_NOT_FOUND;
      }
    }
    
    // These actions apply only when redacting a user comment, not when editing  
    // a moderator comment.
    if (!smartparticipation_core_is_moderator_comment($comment)) {
      
      // Store the original comment if it hasn't already been stored.
      if (smartparticipation_core_field_get_item_value('comment', $comment, 'field_sp_comment_original', 'value') == null) {
        $comment->field_sp_comment_original[LANGUAGE_NONE][0]['value'] = $comment->comment_body[LANGUAGE_NONE][0]['value'];
        // Setting 'format' => 'filtered_html' doesn't accomplish this.
        $comment->field_sp_comment_original[LANGUAGE_NONE][0]['format'] = 'filtered_html';
      }
    
      smartparticipation_core_promote_comment_to_in_progress($comment);
    }

    $comment->comment_body[LANGUAGE_NONE][0]['value'] = $content;
      
    comment_save($comment);

    if (drupal_valid_token($_GET['token'], "comment/$cid/redact")) {
      drupal_json_output(smartparticipation_core_comment_front_end_render_response($cid));
    } else if (drupal_valid_token($_GET['token'], "moderator/comment/$cid/action")) {
      return 'activate';
    } else{
      return MENU_NOT_FOUND;
    }
  }
}

function smartparticipation_core_comment_ajax_render($cid) {
  drupal_json_output(smartparticipation_core_comment_front_end_render_response($cid));
}

/**
* Returns a json object holding the html of a comment rendered for the front-end
* 
* @parm $cid
*   A comment identifier
*/
function smartparticipation_core_comment_front_end_render_response($cid) {
  $output = array();
  $comment = comment_load($cid);
  $comment_view = comment_view($comment, node_load($comment->nid));
  $output['html'] = drupal_render($comment_view);
  return $output;
}

/**
 * Unredact a comment
 *
 * @param $cid
 *   A comment identifier.
 */
function smartparticipation_core_comment_restore_original($cid) {
  
  // It's necessary to use the entity API in order to delete the rows from the
  // field data and revision tables, rather than just setting the values to null.
  if ($comments = entity_load('comment', array($cid))) {
    
    $comment = array_shift($comments);
    
    $comment->comment_body[LANGUAGE_NONE][0]['value'] = $comment->field_sp_comment_original[LANGUAGE_NONE][0]['value'];
    
    unset($comment->field_sp_comment_original[LANGUAGE_NONE][0]);
    
    // Reset the array to zero-based sequential keys
    $comment->field_sp_comment_original[LANGUAGE_NONE] = array_values($comment->field_sp_comment_original[LANGUAGE_NONE]);
    
    // Save the entity
    entity_save('comment', $comment);
    
    return 'deactivate';
  }
    
  return MENU_NOT_FOUND;
}

/**
 * Recommend or unrecommend a comment
 *
 * @param $cid
 *   A comment identifier.
 */
function smartparticipation_core_comment_recommend_or_unrecommend($cid) {
  
  global $user;
  $uid = $user->uid;

  // This should be an integer in the flag_content table
  // But it's coming as an alphanumeric string
  // $sid = $user->sid;
  $fid = db_select('flags','f')
    ->fields('f',array('fid'))
    ->condition('name','comment_recommendation')
    ->execute()
    ->fetchField();

  // Check if a recommendation already exists
  $flag_check = db_select('flag_content','fc')
    ->fields('fc',array('fcid'))
    ->condition('fid',$fid)
    ->condition('content_id',$cid)
    ->condition('content_type','comment')
    ->execute()
    ->fetchField();

  // If a recommendation doesn't exist, create it
  if (!$flag_check) {
    $flag_insert = db_insert('flag_content')
      ->fields(array(
        'fid' => $fid,
        'content_type' => 'comment',
        'content_id' => $cid,
        'uid' => $uid,
        'timestamp' => REQUEST_TIME
        ))
      ->execute();
      
    smartparticipation_core_save_comment_in_progress($cid);
    
    // TODO We are supposed to go to smartparticipation_core_flag() but we never get there. The
    // entire flag module has been sidestepped here. This needs to be rewritten.
    $comment = comment_load($cid);
    $flag = flag_get_flag('comment_recommendation');
    smartparticipation_core_comment_flagged_email_send($comment, $flag);
  
  // If a recommendation does exist, remove it 
  } else {
    $flag_delete = db_delete('flag_content')
      ->condition('fcid',$flag_check)
      ->execute();
  }

  if (drupal_valid_token($_GET['token'], "comment/$cid/recommend")) {
      drupal_json_output(smartparticipation_core_comment_front_end_render_response($cid));      
    } else if (drupal_valid_token($_GET['token'], "moderator/comment/$cid/action")) {
      if (!$flag_check) {
        return 'activate';
      } else{
        return 'deactivate';
      }
    } else{
      return MENU_NOT_FOUND;
    }
}

/**
 * Adds a note to a particular comment
 *
 * @param $cid
 *   A comment identifier.
 * @param $content
 *   Content of the note body
 * @param $note_to
 *   Optional email address to send this note to
 * @param $note_subject
 *   Optional subject of the email sending this note
 */
function smartparticipation_core_comment_add_note($cid, $content = null, $note_to = '', $note_subject = '') {
  if ($comment = comment_load($cid)) {
    global $user;

    $comment_body = $comment->comment_body['und'][0]['value'];

    // From front-end attempt to gather content information from GET
    if ($content == null) {
      if (!empty($_REQUEST['content'])) {
        $content = $_REQUEST['content'];
      } else if (!empty($_GET['input'])) {
        $content = $_GET['input'];
      } else{
        return MENU_NOT_FOUND;
      }
    }


    $node = new stdClass();
    $node->title = 'Note for Comment ' . $cid;
    $node->type = 'sp_comment_note';
    node_object_prepare($node); // Sets some defaults. Invokes hook_prepare() and hook_node_prepare().
    $node->language = 'und'; // Or e.g. 'en' if locale is enabled
    $node->uid = $user->uid;
    $node->status = 1; // (1 or 0): published or not
    $node->promote = 0; // (1 or 0): promoted to front page
    $node->comment = 1; // 2 = comments on, 1 = comments off

    $node->field_sp_comment_note_comment[$node->language][] = array(
        'target_id' => $cid,
      );
    $node->body[$node->language][] = array(
        'value' => $content,
        'body_summary' => '',
        'format' => 'text',
      );

    $node = node_submit($node); // Prepare node for saving
    node_save($node);

    if ($note_to != '' && $note_subject != '') {
      $my_module = 'smartparticipation_core';
      $my_mail_token = microtime();

      $from = $user->email;
      $body = "Here is the note from " . $user->name . ":\n" . $content . "\n\n";
      $body .= "The associated comment is:\n" . $comment_body;
      $message = array(
          'id' => $my_module . '_' . $my_mail_token,
          'from' => $from,
          'to' => $note_to,
          'subject' => $note_subject,
          'body' => array($body),
          'headers' => array(
              'Content-Type' => 'text/plain; charset=UTF-8;',
              'From' => $from,
              'Sender' => $from,
              'Return-Path' => $from,
          ),
      );

      $system = drupal_mail_system($my_module, $my_mail_token);
      $message = $system->format($message);

      $system->mail($message);
    }

    smartparticipation_core_save_comment_in_progress($cid);

    if (drupal_valid_token($_GET['token'], "comment/$cid/add_note")) {
      drupal_json_output(smartparticipation_core_comment_front_end_render_response($cid));
    } else if (drupal_valid_token($_GET['token'], "moderator/comment/$cid/action")) {
      return 'add note success';
    } else{
      return MENU_NOT_FOUND;
    }
    
  }
}

/**
 * Return the moderation status for a specific comment
 */
function _smartparticipation_core_comment_moderation_status($cid) {
  
  $comment = comment_load($cid);
  return smartparticipation_core_field_get_item_value('comment', $comment, 'field_sp_comment_mod_status', 'value');

}


/**
 * Return the moderation action for a specific comment
 */
function _smartparticipation_core_comment_moderation_action($cid) {
  
  $comment = comment_load($cid);
  return smartparticipation_core_field_get_item_value('comment', $comment, 'field_sp_comment_mod_action', 'value');
  
}

/**
  * Creates the initialized statistics array pertaining to a subtopic/topic/proposal node.
  */
function smartparticipation_core_get_com_stats_arr() {
  return array(
    'unread' => 0,
    'in_progress' => 0,
    'done' => 0,
    'reply' => 0,
    'no_reply' => 0,
    'quarantine' => 0,
    'redacted' => 0,
    'recommended' => 0,
    'all_comments' => 0,
  );
}

/**
 * Creates the data structures for nodes-to-titles ($node_titles), proposal, topic, and subtopic node-to-node
 * relations ($node_structure), and node statistics ($node_stats).
 * 
 * TODO - REWRITE
 */
function smartparticipation_core_construct_initialized_node_title_data_structure_arrays() {
  
  $com_stats_arr = smartparticipation_core_get_com_stats_arr();
  
  // Node to relevant statistices
  $node_stats = array('all' => $com_stats_arr);

  // Node to title
  $node_titles = array();
  $node_titles['all'] = t('All Proposals');

  // Array of proposals to topics to subtopics
  $node_structure = array();
  
  $proposal_query = "SELECT np.nid, np.title 
                     FROM {node} np
                     WHERE np.type = 'sp_proposal'
                     AND np.status = 1";
  
  $proposals = db_query($proposal_query);

  $proposal_nids = array();
  
  foreach ($proposals as $proposal) {
    $proposal_nids[] = $proposal->nid;
    $node_stats[$proposal->nid] = $com_stats_arr;
    $node_titles[$proposal->nid] = $proposal->title;
    $node_structure[$proposal->nid] = array();
  }
  
  $proposal_nid_list = implode(',', $proposal_nids);
    
  $topic_query = "SELECT nt.nid, nt.title, pt.entity_id AS proposal_nid
                  FROM {field_data_field_sp_proposal_topic} pt
                  INNER JOIN {node} nt ON pt.field_sp_proposal_topic_nid = nt.nid
                  WHERE pt.entity_id IN (" . $proposal_nid_list . ")
                  AND nt.status = 1";
    
  $topics = db_query($topic_query);
  
  $topics_nids = array();
  
  foreach ($topics as $topic) {
    $topic_nids[] = $topic->nid;
    $node_stats[$topic->nid] = $com_stats_arr;
    $node_titles[$topic->nid] = $topic->title;
    $node_structure[$topic->proposal_nid][$topic->nid] = array();  
  }

  $topic_nid_list = implode(',', $topic_nids);

  $subtopic_query = "SELECT ns.nid, ns.title, ts.entity_id AS topic_nid, pt.entity_id AS proposal_nid
                     FROM {field_data_field_sp_topic_subtopic} ts 
                     INNER JOIN {node} ns ON ts.field_sp_topic_subtopic_nid = ns.nid
                     INNER JOIN {field_data_field_sp_proposal_topic} pt ON pt.field_sp_proposal_topic_nid = ts.entity_id
                     WHERE ts.entity_id IN (" . $topic_nid_list . ")
                     AND ns.status = 1";

  $subtopics = db_query($subtopic_query);
  
  $subtopic_nids = array();
  
  foreach($subtopics as $subtopic) {
    $subtopic_nids[] = $subtopic->nid;
    $node_stats[$subtopic->nid] = $com_stats_arr;
    $node_titles[$subtopic->nid] = $subtopic->title;
    $node_structure[$subtopic->proposal_nid][$subtopic->topic_nid][] = $subtopic->nid;
  }

  // TODO Should return a single data structure rather than three.
  return array ($node_titles, $node_stats, $node_structure);
}

/**
* Gathers all comments data according to the parameters established.
*
* @param $order
*   The ordering (ascending or decending) of the comments.
* @param $order_sup
*   Optional, supplementary ordering (by username or topic name) of comments.
* @param $active_domain_nid
*   Optional, filters comments that only pertain to a certain subtopic/topic identified by the nid.
* @param $domain_filter
*   Optional, filters according to the type statistic the comment pertains to (quarantied, in progress, done, etc.).
* @param $offset
*   Offset to start including comments.
* @param $limit
*   Number of comments to include.
* @param $uid_filter
*   Optional filter according to a user identification number.
*/
function smartparticipation_core_get_comments_data1(&$variables, $order, $order_sup, $active_domain_nid, $domain_filter, $offset, $limit, $uid_filter) {

  $query = 'SELECT cid FROM {comment} c';
  
  $cids = db_query($query)
    ->fetchAllAssoc('cid', PDO::FETCH_ASSOC);

  // Assemble the node data into a structured array
  $sorted_comment_data = array();

  list ($node_titles, $node_stats, $node_structure) = smartparticipation_core_construct_initialized_node_title_data_structure_arrays();

  $offset = intval($offset);

  $comment_counter = 0;
  $checked_comments = array();
  foreach ($cids as $cid) {
    $cid = $cid['cid'];

    if (smartparticipation_core_is_moderator_comment(comment_load($cid))) {
      continue;
    }
    
    $comment_data = smartparticipation_core_comment_data($cid);
    
    $comment_data['reply_permalink'] = 
        smartparticipation_core_get_comment_permalink_from_cid($cid, t('Reply'), array( 
          'target' => '_blank',
          'title' => 'View this comment in the discussion thread to reply',
        ));

    $statistic_to_increase = array('all_comments', $comment_data['moderation_status']);

    if ($comment_data['moderation_action'] != '') {
      $statistic_to_increase[] = $comment_data['moderation_action'];
    }   
    if ($comment_data['original'] != '') {
      $statistic_to_increase[] = 'redacted';
    }    
    if ($comment_data['recommended'] == 'yes') {
      $statistic_to_increase[] = 'recommended';
    }

    // Increment all statistics for relevant proposal and topic
    foreach ($statistic_to_increase as $stat) {
      $node_stats[$comment_data['comment_proposal_nid']][$stat] += 1;
      if (!isset($node_stats[$comment_data['comment_topic_nid']][$stat])) {
        $node_stats[$comment_data['comment_topic_nid']][$stat] = 0;
      }
      $node_stats[$comment_data['comment_topic_nid']][$stat] += 1;
    }

  if ($uid_filter == '') {
    if (($domain_filter == 'unread' || $domain_filter == 'in_progress' || $domain_filter == 'done') && $comment_data['moderation_status'] != $domain_filter) {
      continue;
    } else if ($domain_filter == 'reply' && $comment_data['moderation_action'] != 'reply') {
      continue;
    } else if ($domain_filter == 'no_reply' && $comment_data['moderation_action'] != 'no_reply'/* && $comment_data['moderation_status'] != 'done'*/) {
      continue;
    } else if ($domain_filter == 'quarantine' && $comment_data['moderation_action'] != 'quarantine') {
      continue;
    } else if ($domain_filter == 'redacted' && $comment_data['original'] == '') {
      continue;
    } else if ($domain_filter == 'recommended' && $comment_data['recommended'] == 'no') {
      continue;
    }
  } else if ($uid_filter != $comment_data['uid']) {
    continue;
  }

  if ($active_domain_nid != 'all' && $active_domain_nid != $comment_data['comment_proposal_nid'] && $active_domain_nid != $comment_data['comment_topic_nid']) {
      continue;
  }
  
  $offset--;
  $comment_counter++;
  if (($limit != 'all' || $limit <= 0) && ($offset >= 0 || $limit <= 0)) {
    continue;
  }

  if ($offset <= 0 && $limit > 0) {
    $limit--;
  }

  // Add token to data
  $comment_data['token'] = drupal_get_token('moderator/comment/' . $cid . '/action');

  // Strategy: break apart into subsections all with the same sorting parameter, do subsorting on subsets


    // Topic and user sorting d
  for($i = 0; $i < sizeof($sorted_comment_data) + 1; $i++) {
    if ($i == sizeof($sorted_comment_data)) {
      $sorted_comment_data[] = $comment_data;
      break;
    } else if ( // Supplementary sorting by topic and username
        (($order_sup == 'topics' && $sorted_comment_data[$i]['comment_topic_title'] >= $comment_data['comment_topic_title'])
        || ($order_sup == 'users' && $comment_data['username'] >= $sorted_comment_data[$i]['username'])
        || ($order_sup != 'topics' && $order_sup != 'users'))
        // Always order by proposal before chronology
        && ($sorted_comment_data[$i]['comment_proposal'] >= $comment_data['comment_proposal'])
        // Chronological ordering
        && (($order == 'oldest' && $comment_data['created'] <= $sorted_comment_data[$i]['created'])
        || ($order == 'newest' && $comment_data['created'] >= $sorted_comment_data[$i]['created'])) ) {
          $comment_data_array = array($comment_data);
          array_splice($sorted_comment_data, $i, 0, $comment_data_array );
          break;
      }
    }
  }

  // Add comment counter to comment_data
  $sorted_comment_data['total_com'] = $comment_counter;


  // Add all proposals for all proposals section
  $all_stats = smartparticipation_core_get_com_stats_arr();
  foreach(array_keys($node_stats) as $node_key) {
    // Only choose proposals, not topics (to prevent duplicates)
    if (in_array($node_key, array_keys($node_structure))) {
      foreach(array_keys($all_stats) as $all_stats_key) {
        $all_stats[$all_stats_key] += $node_stats[$node_key][$all_stats_key];
      }
    }
  }
  $node_stats['all'] = $all_stats;

  $variables['node_titles'] = $node_titles;
  $variables['node_structure'] = $node_structure;
  $variables['node_stats'] = $node_stats;
  $variables['comment_data'] = $sorted_comment_data;

}

function smartparticipation_core_get_comments_data(&$variables, $order, $order_sup, $active_domain_nid, $domain_filter, $offset, $limit, $uid_filter) {

  $query = 'SELECT cid FROM {comment} c';

  $cids = db_query($query)
      ->fetchAllAssoc('cid', PDO::FETCH_ASSOC);

  // Assemble the node data into a structured array
  $unsorted_comment_data = array();
  $sorted_comment_data = array();

  list ($node_titles, $node_stats, $node_structure) = smartparticipation_core_construct_initialized_node_title_data_structure_arrays();

  $offset = intval($offset);

  $comment_counter = 0;
  $checked_comments = array();
  foreach ($cids as $cid) {
    $cid = $cid['cid'];

    if (smartparticipation_core_is_moderator_comment(comment_load($cid))) {
      continue;
    }

    $comment_data = smartparticipation_core_comment_data($cid);

    $comment_data['reply_permalink'] =
        smartparticipation_core_get_comment_permalink_from_cid($cid, t('Reply'), array(
            'target' => '_blank',
            'title' => 'View this comment in the discussion thread to reply',
        ));
    
    $comment_data['redact_permalink'] = 
      smartparticipation_core_get_comment_permalink_from_cid($cid, t('Redact'), array(
      'target' => '_blank',
      'title' => 'View this comment in the discussion thread to redact',
    ));
    
    $comment_data['redact_again_permalink'] =
      smartparticipation_core_get_comment_permalink_from_cid($cid, t('Redact again'), array(
        'target' => '_blank',
        'title' => 'View this comment in the discussion thread to redact',
      ));
    
    if (!empty($comment_data['reply_cid'])) {
      $comment_data['edit_reply_permalink'] =
      smartparticipation_core_get_comment_permalink_from_cid($comment_data['reply_cid'], t('Edit Reply'), array(
        'target' => '_blank',
        'title' => 'View the reply in the discussion thread to edit',
      ));
    }

    $statistic_to_increase = array('all_comments', $comment_data['moderation_status']);

    if ($comment_data['moderation_action'] != '') {
      $statistic_to_increase[] = $comment_data['moderation_action'];
    }
    if ($comment_data['original'] != '') {
      $statistic_to_increase[] = 'redacted';
    }
    if ($comment_data['recommended'] == 'yes') {
      $statistic_to_increase[] = 'recommended';
    }

    // Increment all statistics for relevant proposal and topic
    foreach ($statistic_to_increase as $stat) {
      $node_stats[$comment_data['comment_proposal_nid']][$stat] += 1;
      if (!isset($node_stats[$comment_data['comment_topic_nid']][$stat])) {
        $node_stats[$comment_data['comment_topic_nid']][$stat] = 0;
      }
      $node_stats[$comment_data['comment_topic_nid']][$stat] += 1;
    }

    if ($uid_filter == '') {
      if (($domain_filter == 'unread' || $domain_filter == 'in_progress' || $domain_filter == 'done') && $comment_data['moderation_status'] != $domain_filter) {
        continue;
      } else if ($domain_filter == 'reply' && $comment_data['moderation_action'] != 'reply') {
        continue;
      } else if ($domain_filter == 'no_reply' && $comment_data['moderation_action'] != 'no_reply'/* && $comment_data['moderation_status'] != 'done'*/) {
        continue;
      } else if ($domain_filter == 'quarantine' && $comment_data['moderation_action'] != 'quarantine') {
        continue;
      } else if ($domain_filter == 'redacted' && $comment_data['original'] == '') {
        continue;
      } else if ($domain_filter == 'recommended' && $comment_data['recommended'] == 'no') {
        continue;
      }
    } else if ($uid_filter != $comment_data['uid']) {
      continue;
    }

    if ($active_domain_nid != 'all' && $active_domain_nid != $comment_data['comment_proposal_nid'] && $active_domain_nid != $comment_data['comment_topic_nid']) {
      continue;
    }

    $comment_counter++;

    // Add token to data
    $comment_data['token'] = drupal_get_token('moderator/comment/' . $cid . '/action');

    $unsorted_comment_data[$cid] = $comment_data;

  }

  // Sort
  if ($order == 'newest') {
    $time_sort_str = SORT_DESC;
  } else {
    $time_sort_str = SORT_ASC;
  }
  $comment_created = array();
  $comment_topic = array();
  $comment_user = array();
  foreach ($unsorted_comment_data as $key => $row) {
    $comment_created[$key] = $row['created'];
    $comment_topic[$key] = $row['comment_topic_title'];
    $comment_user[$key] = $row['username'];
  }
  if ($order_sup == 'topics') {
    array_multisort($comment_topic, SORT_ASC, $comment_created, $time_sort_str, $unsorted_comment_data);
  } else if ($order_sup == 'users') {
    array_multisort($comment_user, SORT_ASC, $comment_created, $time_sort_str, $unsorted_comment_data);
  } else {
    array_multisort($comment_created, $time_sort_str, $unsorted_comment_data);
  }

  // Offset and Limit
  if ($limit == 'all') {
    $sorted_comment_data = array_slice($unsorted_comment_data, $offset);
  } else {
    $sorted_comment_data = array_slice($unsorted_comment_data, $offset, $limit);
  }

  // Add comment counter to comment_data
  $sorted_comment_data['total_com'] = $comment_counter;

  // Add all proposals for all proposals section
  $all_stats = smartparticipation_core_get_com_stats_arr();
  foreach(array_keys($node_stats) as $node_key) {
    // Only choose proposals, not topics (to prevent duplicates)
    if (in_array($node_key, array_keys($node_structure))) {
      foreach(array_keys($all_stats) as $all_stats_key) {
        $all_stats[$all_stats_key] += $node_stats[$node_key][$all_stats_key];
      }
    }
  }
  $node_stats['all'] = $all_stats;

  $variables['node_titles'] = $node_titles;
  $variables['node_structure'] = $node_structure;
  $variables['node_stats'] = $node_stats;
  $variables['comment_data'] = $sorted_comment_data;

}


/**
  * Gets the position of a comment in the array of comment data. Defaults to
  * -1 if not found.
  *
  * @param $cid
  *   The cid of the comment being searched for.
  * @param $comment_data
  *   The comment data being searched in.
  */
function smartparticipation_core_get_cid_pos_in_comment_data($cid, $comment_data) {
  foreach(array_keys($comment_data) as $key) {
      if ($comment_data[$key]['cid'] == $cid) {
        return $key;
      }
  }
  return -1;
}

/*
  * Menu callback for refreshing the comments on the page.
  */
function smartparticipation_core_ajax_moderator() {

  if ($_GET['cmd'] == 'comment_refresh') {
    smartparticipation_core_refresh_comments();
  }
}

/*
  * Callback to change in filtering on the moderator interface.
  */
function smartparticipation_core_refresh_comments() {
  drupal_json_output(smartparticipation_core_get_comment_data_from_get());
}

/*
  * Gets comment html and data
  */
function smartparticipation_core_get_comment_data_from_get() {
  $items = array();
  $output = array();

  smartparticipation_core_get_comments_data($items, $_GET['order'], $_GET['order_sup'], $_GET['active_domain_nid'], $_GET['domain_filter'], $_GET['offset'], $_GET['limit'], $_GET['uid_filter']);

  $comment_data = $items['comment_data'];
  if ($_GET['uid_filter'] != '') {
    $comment_HTML = theme('moderator_user_view', array('user_data' => (array) user_load($_GET['uid_filter'])));
  } else{
    $comment_HTML = '';
  }


  $counter = 1 + intval($_GET['offset']);
  foreach($comment_data as $comment) {
    if (is_array($comment)) {
      $comment = array_merge(array(
        'active_domain_nid' => $_GET['active_domain_nid'],
        'uid_filter' => $_GET['uid_filter'],
        'page_comment_index' => $counter,
      ), (array)$comment);

      $comment_HTML .= theme('moderator_comment', array('comment' => $comment));
      $counter++;
    }
  }

  if (!$items['comment_data']['total_com']) {
    $comment_HTML .= theme(
      'moderator_no_comments',
      array('no_comments_message' => smartparticipation_core_get_no_comments_message($_GET['domain_filter']))
    );
  }

  $output['comment_data'] = $items['comment_data'];
  $output['comment_HTML'] = $comment_HTML;
  $output['total_com'] = $items['comment_data']['total_com'];

  return $output;
}

/**
 * Generate a message to display in the moderator interface when a filter returns no comments.
 *
 * @param string $domain_filter
 * @return string
 */
function smartparticipation_core_get_no_comments_message($domain_filter = '') {

  if (!empty($domain_filter) && $domain_filter != 'all_comments') {
    $message = 'There are no comments meeting your filter criteria to display.';
  } else {
    $message = 'There are no comments to display.';
  }
  return t($message);
}

/**
 * Menu callback for moderator actions on a comment in the moderator interface.
 *
 * @param $cid
 *   A comment identifier.
 */
function smartparticipation_core_moderator_comment_action($cid) {
  $out_json = array();
  $out_json['status'] = 'failed';

  if (!isset($_GET['token']) || !drupal_valid_token($_GET['token'], "moderator/comment/$cid/action")) {
    return MENU_ACCESS_DENIED;
  }
  else if (!isset($_GET['action'])) {
   $out_json['status'] = 'unrecognized action';
  }
  else if ($comment = comment_load($cid)) {
    $input = null;
    if (!empty($_POST['input'])) {
      $input = $_POST['input'];
    }
    switch ($_GET['action']) {
      // In progress action
      case 'in_progress':
        $out_json['status'] = smartparticipation_core_comment_in_progress($cid);
        break;
      // Add note action
      case 'add_note':
        $out_json['status'] = smartparticipation_core_comment_add_note($cid, $input, $_GET['note_to'], $_GET['note_subject']);
        break;
      // Redact action
      case 'redact':
        $out_json['status'] = smartparticipation_core_comment_redact($cid, $input);
        break;
      // Edit reply to a given comment action
      case 'edit_reply':
        $out_json['status'] = smartparticipation_core_comment_redact($_GET['reply_cid'], $input);
        break;
      // Restore original comment
      case 'restore_original':
        $out_json['status'] = smartparticipation_core_comment_restore_original($cid);
        break;
      // Reply action
      case 'reply':
        $santized_input = htmlentities($input);
        $santized_input = mysql_real_escape_string($santized_input);
        $out_json['status'] = 'activate';
        break;
      // Quarantine action
      case 'quarantine':
        if (! smartparticipation_core_comment_quarantined($comment)) {
          $out_json['status'] = smartparticipation_core_comment_quarantine($cid);
        } else{
          $out_json['status'] = smartparticipation_core_comment_unquarantine($cid);
        }
        break;
      // No Reply action
      case 'no_reply':
        $out_json['status'] = smartparticipation_core_comment_no_reply($cid);
        break;
      // Recommend action
      case 'recommend':
        $out_json['status'] = smartparticipation_core_comment_recommend_or_unrecommend($cid);
        break;
    }
  }

  // May be a better way to do this in the future for just comment_data on $cid, but we need a 
  // limit of all to hit all node_stats and capture this cid's comment_data
  smartparticipation_core_get_comments_data($result_variables, 'latest', '', 'all', 'all_comments', 0, 'all', '');
  $out_json['node_stats'] = $result_variables['node_stats'];
  $out_json['comment_data'] = '';

  $new_query = smartparticipation_core_get_comment_data_from_get();
  $out_json['comment_HTML'] = $new_query['comment_HTML'];
  $out_json['total_com'] = $new_query['total_com'];

  drupal_json_output($out_json);
}

/**
 * Promote an unread comment to in progress. Called after redacting, adding a 
 * note, and recommending a comment. Note that we do change the status of a 
 * comment already marked 'done.'
 * 
 * @param $cid - the comment cid
 */
function smartparticipation_core_save_comment_in_progress($cid) {

  $comment = comment_load($cid);
  smartparticipation_core_promote_comment_to_in_progress($comment);
  comment_save($comment);
}

/**
 * Mark the specified comment in progress if it is unread.
 * @param $comment - the comment object
 */
function smartparticipation_core_promote_comment_to_in_progress(&$comment) {
  
  if (smartparticipation_core_field_get_item_value('comment', $comment, 'field_sp_comment_mod_status', 'value') == 'unread') {
    $comment->field_sp_comment_mod_status[LANGUAGE_NONE][0]['value'] = 'in_progress';
  }  
}

/**
 * Return the data for a single comment as JSON.
 *
 * @param $cid
 */
function smartparticipation_core_get_comment_data($cid) {
  $comment = comment_load($cid);
  // For now sending only comment body but more values can be added as needed.
  $comment_data = array(
    'comment_body' => smartparticipation_core_field_get_item_value('comment', $comment, 'comment_body', 'value'),
  );
  drupal_json_output($comment_data);
}
 